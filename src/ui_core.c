#include "ui_core.h"

#include <pthread.h>
#include <stdlib.h>
#include <string.h>

#define UI_EVENT_QUEUE_SIZE 128

struct ui_context {
    ui_color_t framebuffer[UI_FRAMEBUFFER_WIDTH * UI_FRAMEBUFFER_HEIGHT];
    pthread_mutex_t fb_lock;
    pthread_mutex_t ev_lock;
    ui_event_t ev_queue[UI_EVENT_QUEUE_SIZE];
    size_t ev_head;
    size_t ev_count;
    const ui_hal_ops_t *hal;
    void *user_data;
};

static const uint8_t font5x7[95][5] = {
    {0x00,0x00,0x00,0x00,0x00}, {0x00,0x00,0x5F,0x00,0x00}, {0x00,0x07,0x00,0x07,0x00},
    {0x14,0x7F,0x14,0x7F,0x14}, {0x24,0x2A,0x7F,0x2A,0x12}, {0x23,0x13,0x08,0x64,0x62},
    {0x36,0x49,0x55,0x22,0x50}, {0x00,0x05,0x03,0x00,0x00}, {0x00,0x1C,0x22,0x41,0x00},
    {0x00,0x41,0x22,0x1C,0x00}, {0x14,0x08,0x3E,0x08,0x14}, {0x08,0x08,0x3E,0x08,0x08},
    {0x00,0x50,0x30,0x00,0x00}, {0x08,0x08,0x08,0x08,0x08}, {0x60,0x60,0x00,0x00,0x00},
    {0x20,0x10,0x08,0x04,0x02}, {0x3E,0x51,0x49,0x45,0x3E}, {0x00,0x42,0x7F,0x40,0x00},
    {0x72,0x49,0x49,0x49,0x46}, {0x21,0x41,0x49,0x4D,0x33}, {0x18,0x14,0x12,0x7F,0x10},
    {0x27,0x45,0x45,0x45,0x39}, {0x3C,0x4A,0x49,0x49,0x31}, {0x41,0x21,0x11,0x09,0x07},
    {0x36,0x49,0x49,0x49,0x36}, {0x46,0x49,0x49,0x29,0x1E}, {0x00,0x36,0x36,0x00,0x00},
    {0x00,0x56,0x36,0x00,0x00}, {0x08,0x14,0x22,0x41,0x00}, {0x14,0x14,0x14,0x14,0x14},
    {0x00,0x41,0x22,0x14,0x08}, {0x02,0x01,0x59,0x09,0x06}, {0x3E,0x41,0x5D,0x59,0x4E},
    {0x7C,0x12,0x11,0x12,0x7C}, {0x7F,0x49,0x49,0x49,0x36}, {0x3E,0x41,0x41,0x41,0x22},
    {0x7F,0x41,0x41,0x22,0x1C}, {0x7F,0x49,0x49,0x49,0x41}, {0x7F,0x09,0x09,0x09,0x01},
    {0x3E,0x41,0x49,0x49,0x7A}, {0x7F,0x08,0x08,0x08,0x7F}, {0x00,0x41,0x7F,0x41,0x00},
    {0x20,0x40,0x41,0x3F,0x01}, {0x7F,0x08,0x14,0x22,0x41}, {0x7F,0x40,0x40,0x40,0x40},
    {0x7F,0x02,0x0C,0x02,0x7F}, {0x3E,0x41,0x41,0x41,0x3E}, {0x7F,0x09,0x09,0x09,0x06},
    {0x3E,0x41,0x51,0x21,0x5E}, {0x7F,0x09,0x19,0x29,0x46}, {0x46,0x49,0x49,0x49,0x31},
    {0x01,0x01,0x7F,0x01,0x01}, {0x3F,0x40,0x40,0x40,0x3F}, {0x1F,0x20,0x40,0x20,0x1F},
    {0x3F,0x40,0x38,0x40,0x3F}, {0x63,0x14,0x08,0x14,0x63}, {0x07,0x08,0x70,0x08,0x07},
    {0x61,0x51,0x49,0x45,0x43}, {0x00,0x7F,0x41,0x41,0x00}, {0x02,0x04,0x08,0x10,0x20},
    {0x00,0x41,0x41,0x7F,0x00}, {0x04,0x02,0x01,0x02,0x04}, {0x40,0x40,0x40,0x40,0x40},
    {0x00,0x01,0x02,0x04,0x00}, {0x20,0x54,0x54,0x54,0x78}, {0x7F,0x48,0x44,0x44,0x38},
    {0x38,0x44,0x44,0x44,0x20}, {0x38,0x44,0x44,0x48,0x7F}, {0x38,0x54,0x54,0x54,0x18},
    {0x08,0x7E,0x09,0x01,0x02}, {0x0C,0x52,0x52,0x52,0x3E}, {0x7F,0x08,0x04,0x04,0x78},
    {0x00,0x44,0x7D,0x40,0x00}, {0x20,0x40,0x44,0x3D,0x00}, {0x7F,0x10,0x28,0x44,0x00},
    {0x00,0x41,0x7F,0x40,0x00}, {0x7C,0x04,0x18,0x04,0x78}, {0x38,0x44,0x44,0x44,0x38},
    {0x7C,0x14,0x14,0x14,0x08}, {0x08,0x14,0x14,0x18,0x7C}, {0x7C,0x08,0x04,0x04,0x08},
    {0x48,0x54,0x54,0x54,0x20}, {0x04,0x3F,0x44,0x40,0x20}, {0x3C,0x40,0x40,0x20,0x7C},
    {0x1C,0x20,0x40,0x20,0x1C}, {0x3C,0x40,0x30,0x40,0x3C}, {0x44,0x28,0x10,0x28,0x44},
    {0x0C,0x50,0x50,0x50,0x3C}, {0x44,0x64,0x54,0x4C,0x44}, {0x00,0x08,0x36,0x41,0x00},
    {0x00,0x00,0x7F,0x00,0x00}, {0x00,0x41,0x36,0x08,0x00}, {0x10,0x08,0x08,0x10,0x08}
};

static inline void ui_set_pixel_locked(ui_context_t *ctx, int x, int y, ui_color_t color)
{
    if ((unsigned)x >= UI_FRAMEBUFFER_WIDTH || (unsigned)y >= UI_FRAMEBUFFER_HEIGHT) {
        return;
    }
    ctx->framebuffer[y * UI_FRAMEBUFFER_WIDTH + x] = color;
}

ui_context_t *ui_context_create(const ui_hal_ops_t *hal)
{
    if (!hal || !hal->init || !hal->commit_frame) {
        return NULL;
    }

    ui_context_t *ctx = malloc(sizeof(*ctx));
    if (!ctx) {
        return NULL;
    }

    memset(ctx->framebuffer, 0, sizeof(ctx->framebuffer));
    pthread_mutex_init(&ctx->fb_lock, NULL);
    pthread_mutex_init(&ctx->ev_lock, NULL);
    ctx->ev_head = 0;
    ctx->ev_count = 0;
    ctx->hal = hal;
    ctx->user_data = hal->user_data;

    if (!hal->init(ctx)) {
        pthread_mutex_destroy(&ctx->ev_lock);
        pthread_mutex_destroy(&ctx->fb_lock);
        free(ctx);
        return NULL;
    }

    return ctx;
}

void ui_context_destroy(ui_context_t *ctx)
{
    if (!ctx) {
        return;
    }
    if (ctx->hal && ctx->hal->deinit) {
        ctx->hal->deinit(ctx);
    }
    pthread_mutex_destroy(&ctx->ev_lock);
    pthread_mutex_destroy(&ctx->fb_lock);
    free(ctx);
}

void ui_context_clear(ui_context_t *ctx, ui_color_t color)
{
    if (!ctx) {
        return;
    }
    pthread_mutex_lock(&ctx->fb_lock);
    for (size_t i = 0; i < UI_FRAMEBUFFER_WIDTH * UI_FRAMEBUFFER_HEIGHT; ++i) {
        ctx->framebuffer[i] = color;
    }
    pthread_mutex_unlock(&ctx->fb_lock);
}

void ui_context_fill_rect(ui_context_t *ctx, int x, int y, int width, int height,
                          ui_color_t color)
{
    if (!ctx || width <= 0 || height <= 0) {
        return;
    }
    int x0 = x < 0 ? 0 : x;
    int y0 = y < 0 ? 0 : y;
    int x1 = x + width;
    int y1 = y + height;
    if (x1 > UI_FRAMEBUFFER_WIDTH) {
        x1 = UI_FRAMEBUFFER_WIDTH;
    }
    if (y1 > UI_FRAMEBUFFER_HEIGHT) {
        y1 = UI_FRAMEBUFFER_HEIGHT;
    }

    pthread_mutex_lock(&ctx->fb_lock);
    for (int row = y0; row < y1; ++row) {
        ui_color_t *base = &ctx->framebuffer[row * UI_FRAMEBUFFER_WIDTH + x0];
        for (int col = x0; col < x1; ++col) {
            *base++ = color;
        }
    }
    pthread_mutex_unlock(&ctx->fb_lock);
}

void ui_context_set_pixel(ui_context_t *ctx, int x, int y, ui_color_t color)
{
    if (!ctx) {
        return;
    }
    pthread_mutex_lock(&ctx->fb_lock);
    ui_set_pixel_locked(ctx, x, y, color);
    pthread_mutex_unlock(&ctx->fb_lock);
}

void ui_context_draw_char(ui_context_t *ctx, int x, int y, char ch, ui_color_t color)
{
    if (!ctx || ch < 32 || ch > 126) {
        return;
    }
    const uint8_t *glyph = font5x7[ch - 32];
    pthread_mutex_lock(&ctx->fb_lock);
    for (int col = 0; col < 5; ++col) {
        uint8_t column = glyph[col];
        for (int row = 0; row < 7; ++row) {
            if (column & (1 << row)) {
                ui_set_pixel_locked(ctx, x + col, y + row, color);
            }
        }
    }
    pthread_mutex_unlock(&ctx->fb_lock);
}

void ui_context_draw_text(ui_context_t *ctx, int x, int y, const char *text, ui_color_t color)
{
    if (!ctx || !text) {
        return;
    }
    int cursor = x;
    for (const char *p = text; *p; ++p) {
        ui_context_draw_char(ctx, cursor, y, *p, color);
        cursor += 6;
    }
}

bool ui_context_poll_event(ui_context_t *ctx, ui_event_t *event)
{
    if (!ctx || !event) {
        return false;
    }
    pthread_mutex_lock(&ctx->ev_lock);
    if (ctx->ev_count == 0) {
        pthread_mutex_unlock(&ctx->ev_lock);
        return false;
    }
    *event = ctx->ev_queue[ctx->ev_head];
    ctx->ev_head = (ctx->ev_head + 1) % UI_EVENT_QUEUE_SIZE;
    ctx->ev_count--;
    pthread_mutex_unlock(&ctx->ev_lock);
    return true;
}

bool ui_context_post_event(ui_context_t *ctx, const ui_event_t *event)
{
    if (!ctx || !event) {
        return false;
    }
    pthread_mutex_lock(&ctx->ev_lock);
    if (ctx->ev_count == UI_EVENT_QUEUE_SIZE) {
        pthread_mutex_unlock(&ctx->ev_lock);
        return false;
    }
    size_t insert = (ctx->ev_head + ctx->ev_count) % UI_EVENT_QUEUE_SIZE;
    ctx->ev_queue[insert] = *event;
    ctx->ev_count++;
    pthread_mutex_unlock(&ctx->ev_lock);
    return true;
}

void ui_context_render(ui_context_t *ctx)
{
    if (!ctx || !ctx->hal || !ctx->hal->commit_frame) {
        return;
    }
    pthread_mutex_lock(&ctx->fb_lock);
    ctx->hal->commit_frame(ctx, ctx->framebuffer);
    pthread_mutex_unlock(&ctx->fb_lock);
}

void *ui_context_user_data(ui_context_t *ctx)
{
    return ctx ? ctx->user_data : NULL;
}

void ui_context_set_user_data(ui_context_t *ctx, void *data)
{
    if (ctx) {
        ctx->user_data = data;
    }
}

const ui_hal_ops_t *ui_context_hal(const ui_context_t *ctx)
{
    return ctx ? ctx->hal : NULL;
}
